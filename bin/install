#!/usr/bin/env ruby
# frozen_string_literal: true

# rubocop:disable Lint/MissingCopEnableDirective,Style/FormatString,Style/GlobalVars,Style/StderrPuts

require 'bundler'
begin
  Bundler.setup
rescue Bundler::RubyVersionMismatch => ex
  $stderr.puts ex.message
  exit 1
end

require 'mkmf'
require 'optparse'
require 'pathname'
require 'rainbow'
require 'set'
require 'shellwords'

HOME = Pathname.new(Dir.home).freeze
LNK_ROOT = HOME.join('.config/dotfiles').freeze
SRC_ROOT = Pathname.new(__dir__).parent.freeze

Options = Struct.new(:dry_run, :fast, :force, :verbose)

def exe_exists?(exe)
  MakeMakefile.find_executable0(exe)
end

def system!(*args, &block)
  if $options.verbose
    args.delete('--quiet')
  end
  system(*args, &block) or raise 'command failed'
end

def copy(src, dest)
  run do
    if src.exist? && dest.exist?
      FileUtils.rm(dest, force: true)
    end
    FileUtils.cp(src, dest, preserve: false)
    FileUtils.chmod('u+w', dest)
  end
end

def link_status(original, link)
  if link.exist? || link.symlink?
    if link.symlink? && link.readlink == original
      :ok
    else
      :other
    end
  else
    :unlinked
  end
end

def link(original, link, force: $options.force)
  link_rel = link.relative_path_from(HOME)
  original_rel = original.relative_path_from(HOME)

  case [link_status(original, link), force]
  when [:ok, true], [:ok, false]
    if $options.verbose
      $stdout.puts Rainbow('Already linked: ~/%s' % link_rel)
    end
  when [:other, false]
    $stdout.puts Rainbow('Exists (skipping): ~/%s' % link_rel).yellow
  when [:unlinked, true], [:unlinked, false], [:other, true]
    run { link.parent.mkpath }
    if force && (link.exist? || link.symlink?)
      run { link.delete }
    end
    run { File.symlink(original, link) }
    lnk_msg = '~/%s => ~/%s' % [link_rel, original_rel]
    if force
      $stdout.puts Rainbow("Forced: #{lnk_msg}").green
    else
      $stdout.puts Rainbow("Linked: #{lnk_msg}").green
    end
  else raise
  end
end

def abort(*lines)
  msg = lines.join("\n")
  $stderr.puts Rainbow('FATAL: %s' % msg).red
  exit(false)
end

def warn(*lines)
  msg = lines.join("\n")
  $stderr.puts Rainbow('WARNING: %s' % msg).yellow
end

def step(msg)
  $stderr.puts "#{Rainbow('==>').blue} #{Rainbow(msg).bold}"
  yield
end

def run(dry_run: $options.dry_run)
  yield unless dry_run
end

def parse_options
  options = Options.new(false, false, false)
  OptionParser.new do |opts|
    opts.banner = 'Usage: install [options]'
    opts.on('-d', '--dry-run', 'Output what would be done without doing anything') do |val|
      options.dry_run = val
    end
    opts.on('--force', 'Overwrite existing files') do |val|
      options.force = val
    end
    opts.on('-F', '--fast', 'Skips submodule initialization') do
      options.fast = true
    end
    opts.on('--verbose', 'Log verbose messaging') do |val|
      options.verbose = val
    end
    opts.on('-h', '--help', 'Show help') do
      puts opts
      exit
    end
  end.parse!
  options.freeze
end

def firefox_profiles
  profile_root = HOME.join('Library/Application Support/Firefox/Profiles')
  profile_root.children.select(&:directory?)
end

def default_firefox_profile
  prospective_profile_paths = [
    HOME.join('Library/Application Support/Firefox/Profiles'),
    HOME.join('.mozilla/profiles'),
  ]
  profile_root = prospective_profile_paths.detect(&:exist?)
  return unless profile_root
  default_profile_name = Dir.glob('*.default', base: profile_root).first
  return unless default_profile_name
  default_profile = profile_root.join(default_profile_name)
  default_profile.exist? && default_profile
end

def install!
  FileUtils.cd(SRC_ROOT)

  unless $options.fast
    step 'Syncing submodules' do
      run { system!(*%w[git submodule sync --quiet --recursive]) }
    end

    step 'Installing submodules' do
      run { system!(*%w[git submodule update --quiet --init --jobs 2 --recursive]) }
    end

    step 'Pruning (some) submodules' do
      run { system!(*%w[git clean -d -f -f lib/vim/bundle]) }
    end
  end

  step 'Auditing Vim packages' do
    bundle_plugins = SRC_ROOT.join('lib/vim/bundle').children.to_set
    start_packages = SRC_ROOT.join('lib/vim/pack/user/start').children
    opt_packages = SRC_ROOT.join('lib/vim/pack/user/opt').children
    packages = start_packages + opt_packages
    packaged_plugins = packages.map(&:realdirpath).to_set

    dead_packages = packages.reject(&:exist?)
    missing_packages = bundle_plugins - packaged_plugins
    duplicated_packages = packages
      .group_by(&:realdirpath)
      .select { |_real_path, package_paths| package_paths.size > 1 }

    if dead_packages.any?
      warn(
        'The following Vim package links are dead:',
        *dead_packages.map { |path| format('  - %s', path.to_s) },
      )
    end
    if missing_packages.any?
      warn(
        'The following Vim plugins are not linked into packages:',
        *missing_packages.map { |path| format('  - %s', path.to_s) },
      )
    end
    if duplicated_packages.any?
      abort(
        'The following Vim plugins are linked to multiple packages:',
        *duplicated_packages.map do |plugin_path, package_paths|
          format('  - %s: %s', plugin_path, package_paths.join(', '))
        end,
      )
    end
  end

  step 'Cloning into config' do
    run { LNK_ROOT.mkpath }
    run { system!(*%w[rsync --quiet --archive --delete --chmod=F-w --exclude=.git], SRC_ROOT.join('lib').realpath.to_s.concat('/'), LNK_ROOT.realpath.to_s) }
  end

  step 'Linking root files' do
    LNK_ROOT.join('root').children.each do |path|
      link(path, HOME.join(".#{path.basename}"))
    end
  end

  step 'Linking bin files' do
    LNK_ROOT.join('bin').children.each do |path|
      link(path, HOME.join("bin/#{path.basename}"))
    end
  end

  step 'Linking .config files' do
    config_src_root = LNK_ROOT.join('config')
    Pathname.glob(config_src_root.join('**/*'), File::FNM_DOTMATCH).select(&:file?).each do |path|
      link(path, HOME.join('.config', path.relative_path_from(config_src_root)))
    end
  end

  step 'Linking spacemacs' do
    emacs_root = HOME.join('.emacs.d')
    emacs_root.mkdir unless emacs_root.exist?
    %w[core layers init.el].each do |fname|
      link(LNK_ROOT.join('spacemacs', fname), emacs_root.join(fname))
    end
  end

  step 'Linking Firefox custom profile' do
    default_firefox_profile = default_firefox_profile()
    if default_firefox_profile
      run { default_firefox_profile.join('chrome').mkpath }
      link(LNK_ROOT.join('firefox/userChrome.css'), default_firefox_profile.join('chrome/userChrome.css'))
      copy(LNK_ROOT.join('firefox/userContent.css'), default_firefox_profile.join('chrome/userContent.css'))
      firefox_profiles.each do |firefox_profile|
        link(LNK_ROOT.join('firefox/user.js'), firefox_profile.join('user.js'))
      end
    else
      warn 'Skipping because Firefox profile cannot be found'
    end
  end

  if `uname`.strip.match?(/\bdarwin\b/i)
    step 'Linking macOS-specific configuration' do
      key_bindings_path = HOME.join('Library/KeyBindings')
      run { key_bindings_path.mkpath }
      link(LNK_ROOT.join('macos/DefaultKeyBinding.dict'), key_bindings_path.join('DefaultKeyBinding.dict'))
    end
  end

  step 'Installing terminfo entries' do
    if exe_exists?('toe')
      SRC_ROOT.join('lib', 'terminfo').children.each do |entry|
        name = entry.basename.to_s.split('.', 2).first
        if ! system "toe -a | grep --quiet #{Shellwords.escape(name)}"
          run { system!('tic', '-o', HOME.join('.terminfo').to_s, entry.realpath.to_s) }
        end
      end
    else
      warn 'Skipping because “toe” cannot be found'
    end
  end
end

begin
  $options = parse_options
rescue OptionParser::InvalidOption => ex
  abort(ex.message)
end
install!
